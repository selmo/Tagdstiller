import React, { useEffect, useState, useCallback, useRef } from 'react';
import axios from 'axios';
import { UploadedFile } from '../types/api';
import AdvancedPDFViewer from './AdvancedPDFViewer';

const API_BASE_URL = 'http://localhost:58000';

interface DocumentViewerProps {
  file: UploadedFile;
  selectedKeywords?: string[];
  targetPosition?: { page?: number; line?: number; column?: number };
  onClose: () => void;
}

export default function DocumentViewerSimple({ file, selectedKeywords = [], targetPosition, onClose }: DocumentViewerProps) {
  const safeKeywords = Array.isArray(selectedKeywords) 
    ? selectedKeywords.map(k => typeof k === 'string' ? k : String(k)).filter(Boolean)
    : [];
  const [content, setContent] = useState<string>('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [fileType, setFileType] = useState<string>('');
  const [highlightKeywords, setHighlightKeywords] = useState(true);
  const [pdfUrl, setPdfUrl] = useState<string | null>(null);
  const [showTextContent, setShowTextContent] = useState(false);
  const [useAdvancedPDFViewer, setUseAdvancedPDFViewer] = useState(false);
  
  // ÎìúÎûòÍ∑∏ Î∞è ÌÅ¨Í∏∞ Ï°∞Ï†à ÏÉÅÌÉú
  const [isMaximized, setIsMaximized] = useState(false);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [size, setSize] = useState({ width: 1000, height: 700 });
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [resizeStart, setResizeStart] = useState({ x: 0, y: 0, width: 0, height: 0 });
  const modalRef = useRef<HTMLDivElement>(null);
  const headerRef = useRef<HTMLDivElement>(null);

  const fetchFileContent = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const extension = file.filename.split('.').pop()?.toLowerCase() || '';
      setFileType(extension);
      
      if (extension === 'pdf') {
        // For PDF files, get the binary file for browser PDF viewer
        try {
          const response = await axios.get(`${API_BASE_URL}/projects/${file.id}/download`, {
            responseType: 'blob'
          });
          let url = URL.createObjectURL(response.data);
          
          // PDF URLÏóê ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÍ∞Ä
          const urlParams = [];
          
          // ÌéòÏù¥ÏßÄ ÌååÎùºÎØ∏ÌÑ∞
          if (targetPosition?.page) {
            urlParams.push(`page=${targetPosition.page}`);
          }
          
          // Í≤ÄÏÉâ ÌååÎùºÎØ∏ÌÑ∞ (ÌÇ§ÏõåÎìú ÌïòÏù¥ÎùºÏù¥Ìä∏)
          if (safeKeywords.length > 0) {
            // Ï≤´ Î≤àÏß∏ ÌÇ§ÏõåÎìúÎ°ú Í≤ÄÏÉâ (PDF.js search Í∏∞Îä• ÌôúÏö©)
            const searchKeyword = safeKeywords[0];
            urlParams.push(`search=${encodeURIComponent(searchKeyword)}`);
          }
          
          if (urlParams.length > 0) {
            url += `#${urlParams.join('&')}`;
            console.log(`üìç PDF URL with parameters: ${url}`);
            console.log(`üìç Parameters: ${urlParams.join(', ')}`);
          }
          
          setPdfUrl(url);
          
          // Also try to get parsed content for keyword highlighting
          try {
            const contentResponse = await axios.get(`${API_BASE_URL}/projects/${file.project_id}/files/${file.id}/content`);
            setContent(contentResponse.data.content || '');
          } catch (contentErr) {
            setContent('');
          }
        } catch (err) {
          setError('PDF ÌååÏùºÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.');
        }
      } else {
        const response = await axios.get(`${API_BASE_URL}/projects/${file.project_id}/files/${file.id}/content`);
        setContent(response.data.content || 'Î¨∏ÏÑúÍ∞Ä ÌååÏã±ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÌÇ§ÏõåÎìú Ï∂îÏ∂úÏùÑ Î®ºÏ†Ä Ïã§ÌñâÌï¥Ï£ºÏÑ∏Ïöî.');
      }
    } catch (err) {
      console.error('Error fetching file content:', err);
      setError('ÌååÏùº ÎÇ¥Ïö©ÏùÑ Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
    } finally {
      setLoading(false);
    }
  }, [file.id, file.filename, file.project_id, targetPosition]);

  useEffect(() => {
    fetchFileContent();
  }, [fetchFileContent]);

  // PDF ÌååÏùºÏóêÏÑú ÏúÑÏπò Ïù¥ÎèôÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞ ÏûêÎèôÏúºÎ°ú ÌÖçÏä§Ìä∏ Î∑∞ ÌëúÏãú
  useEffect(() => {
    if (fileType === 'pdf' && (targetPosition || safeKeywords.length > 0)) {
      setShowTextContent(true);
    }
  }, [fileType, targetPosition, safeKeywords.length]);

  // Separate cleanup effect for pdfUrl
  useEffect(() => {
    return () => {
      // Cleanup blob URL to prevent memory leaks
      if (pdfUrl) {
        URL.revokeObjectURL(pdfUrl);
      }
    };
  }, [pdfUrl]);

  // Scroll to target position when content is loaded
  useEffect(() => {
    if (!loading && content && targetPosition) {
      console.log('üìç ÏúÑÏπò Ïù¥Îèô ÏãúÎèÑ:', targetPosition);
      console.log('üìÑ ÏΩòÌÖêÏ∏† Í∏∏Ïù¥:', content.length);
      console.log('üìù ÏΩòÌÖêÏ∏† ÎùºÏù∏ Ïàò:', content.split('\n').length);
      
      // ÏßÄÏó∞ÏùÑ ÎäòÎ†§ÏÑú DOMÏù¥ ÏôÑÏ†ÑÌûà Î†åÎçîÎßÅÎêú ÌõÑ Ïä§ÌÅ¨Î°§
      setTimeout(() => {
        scrollToTargetPosition();
      }, 300);
    }
  }, [loading, content, targetPosition]);

  const scrollToTargetPosition = () => {
    if (!targetPosition) {
      console.log('‚ùå targetPositionÏù¥ ÏóÜÏäµÎãàÎã§');
      return;
    }

    console.log('üéØ scrollToTargetPosition Ïã§Ìñâ:', targetPosition);

    const contentElement = document.getElementById('document-content');
    if (!contentElement) {
      console.log('‚ùå document-content ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
      return;
    }

    console.log('‚úÖ document-content ÏöîÏÜå Ï∞æÏùå:', contentElement);

    // 1. ÎùºÏù∏ Î≤àÌò∏ Í∏∞Î∞ò Ïä§ÌÅ¨Î°§
    if (targetPosition.line) {
      const lines = content.split('\n');
      const targetLine = targetPosition.line - 1; // 0-indexed
      
      console.log(`üìã Ï¥ù ÎùºÏù∏ Ïàò: ${lines.length}, ÎåÄÏÉÅ ÎùºÏù∏: ${targetPosition.line} (0-based: ${targetLine})`);
      
      if (targetLine >= 0 && targetLine < lines.length) {
        const lineHeight = 24; // line-heightÏôÄ ÏùºÏπò
        const scrollPosition = targetLine * lineHeight;
        
        console.log(`üìè Í≥ÑÏÇ∞Îêú Ïä§ÌÅ¨Î°§ ÏúÑÏπò: ${scrollPosition}px (ÎùºÏù∏ ÎÜíÏù¥: ${lineHeight}px)`);
        
        contentElement.scrollTo({
          top: Math.max(0, scrollPosition - 150),
          behavior: 'smooth'
        });
        
        console.log(`‚úÖ Ïä§ÌÅ¨Î°§ ÏôÑÎ£å: ${Math.max(0, scrollPosition - 150)}pxÎ°ú Ïù¥Îèô`);
        
        // Ìï¥Îãπ ÎùºÏù∏ ÌïòÏù¥ÎùºÏù¥Ìä∏ Ìö®Í≥º
        highlightTargetLine(targetLine);
      } else {
        console.log(`‚ùå ÎùºÏù∏ Î≤àÌò∏Í∞Ä Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: ${targetLine} (Ï¥ù ÎùºÏù∏: ${lines.length})`);
      }
    } else {
      console.log('‚ùå targetPosition.lineÏù¥ ÏóÜÏäµÎãàÎã§');
    }
  };

  const highlightTargetLine = (lineNumber: number) => {
    // ÏûÑÏãú ÌïòÏù¥ÎùºÏù¥Ìä∏ Ìö®Í≥º Ï∂îÍ∞Ä
    const contentElement = document.getElementById('document-content');
    if (!contentElement) return;

    // Í∏∞Ï°¥ ÌïòÏù¥ÎùºÏù¥Ìä∏ Ï†úÍ±∞
    const existingHighlight = document.querySelector('.target-line-highlight');
    if (existingHighlight) {
      existingHighlight.remove();
    }

    // ÏÉà ÌïòÏù¥ÎùºÏù¥Ìä∏ ÏöîÏÜå ÏÉùÏÑ±
    const highlight = document.createElement('div');
    highlight.className = 'target-line-highlight';
    highlight.style.cssText = `
      position: absolute;
      left: 0;
      right: 0;
      height: 24px;
      background-color: rgba(255, 235, 59, 0.3);
      border-left: 4px solid #ff9800;
      pointer-events: none;
      z-index: 10;
      top: ${lineNumber * 24}px;
      animation: fadeOut 3s ease-out forwards;
    `;

    // CSS Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∂îÍ∞Ä
    if (!document.querySelector('#highlight-style')) {
      const style = document.createElement('style');
      style.id = 'highlight-style';
      style.textContent = `
        @keyframes fadeOut {
          0% { opacity: 1; }
          70% { opacity: 1; }
          100% { opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }

    contentElement.style.position = 'relative';
    contentElement.appendChild(highlight);

    // 3Ï¥à ÌõÑ Ï†úÍ±∞
    setTimeout(() => {
      if (highlight.parentNode) {
        highlight.remove();
      }
    }, 3000);
  };

  // ÎìúÎûòÍ∑∏ ÏãúÏûë
  const handleMouseDown = (e: React.MouseEvent) => {
    if (isMaximized) return;
    if (e.target !== headerRef.current && !headerRef.current?.contains(e.target as Node)) return;
    
    setIsDragging(true);
    setDragStart({
      x: e.clientX - position.x,
      y: e.clientY - position.y
    });
  };

  // ÌÅ¨Í∏∞ Ï°∞Ï†à ÏãúÏûë
  const handleResizeStart = (e: React.MouseEvent) => {
    if (isMaximized) return;
    e.stopPropagation();
    setIsResizing(true);
    setResizeStart({
      x: e.clientX,
      y: e.clientY,
      width: size.width,
      height: size.height
    });
  };

  // ÎßàÏö∞Ïä§ Ïù¥Îèô Ï≤òÎ¶¨
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (isDragging && !isMaximized) {
        setPosition({
          x: e.clientX - dragStart.x,
          y: e.clientY - dragStart.y
        });
      } else if (isResizing && !isMaximized) {
        const newWidth = Math.max(400, resizeStart.width + (e.clientX - resizeStart.x));
        const newHeight = Math.max(300, resizeStart.height + (e.clientY - resizeStart.y));
        setSize({ width: newWidth, height: newHeight });
      }
    };

    const handleMouseUp = () => {
      setIsDragging(false);
      setIsResizing(false);
    };

    if (isDragging || isResizing) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [isDragging, isResizing, dragStart, resizeStart]);

  // ÏµúÎåÄÌôî/Î≥µÏõê
  const toggleMaximize = () => {
    setIsMaximized(!isMaximized);
  };

  // Ï¥àÍ∏∞ ÏúÑÏπò ÏÑ§Ï†ï (ÌôîÎ©¥ Ï§ëÏïô)
  useEffect(() => {
    const centerX = (window.innerWidth - size.width) / 2;
    const centerY = (window.innerHeight - size.height) / 2;
    setPosition({ x: centerX, y: centerY });
  }, []);

  // Safety check - after hooks
  if (!file || !file.filename) {
    return null;
  }

  const highlightText = (text: string): string => {
    if (!highlightKeywords || safeKeywords.length === 0) return text;
    
    let highlightedText = text;
    
    safeKeywords.forEach((keyword, index) => {
      if (!keyword) return;
      
      const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(`(${escapedKeyword})`, 'gi');
      const colors = [
        'rgba(59, 130, 246, 0.3)', 'rgba(34, 197, 94, 0.3)', 'rgba(168, 85, 247, 0.3)',
        'rgba(251, 146, 60, 0.3)', 'rgba(236, 72, 153, 0.3)', 'rgba(250, 204, 21, 0.3)'
      ];
      const color = colors[index % colors.length];
      highlightedText = highlightedText.replace(
        regex,
        `<span style="background-color: ${color}; padding: 2px 4px; border-radius: 3px; font-weight: 500;">$1</span>`
      );
    });
    
    return highlightedText;
  };

  const renderContent = () => {
    if (loading) {
      return (
        <div className="flex items-center justify-center h-full">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
        </div>
      );
    }

    if (error) {
      return (
        <div className="flex items-center justify-center h-full">
          <div className="text-red-600 text-center">
            <p className="text-xl mb-2">‚ö†Ô∏è</p>
            <p>{error}</p>
          </div>
        </div>
      );
    }

    if (fileType === 'pdf') {
      return (
        <div className="flex flex-col h-full">
          {/* PDF Viewer Controls */}
          <div className="flex items-center justify-between p-4 border-b bg-gray-50">
            <div className="flex items-center space-x-4">
              <span className="text-sm font-medium">PDF Î∑∞Ïñ¥</span>
              {targetPosition && (
                <div className="flex items-center space-x-2">
                  <span className="text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded">
                    üìç {targetPosition.page ? `ÌéòÏù¥ÏßÄ ${targetPosition.page}` : ''}
                    {targetPosition.line ? `, ÎùºÏù∏ ${targetPosition.line}` : ''}
                  </span>
                </div>
              )}
              {safeKeywords.length > 0 && (
                <div className="flex items-center space-x-2">
                  <span className="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">
                    üîç Í≤ÄÏÉâ: {safeKeywords[0]} {safeKeywords.length > 1 ? `Ïô∏ ${safeKeywords.length - 1}Í∞ú` : ''}
                  </span>
                  <button
                    onClick={() => setUseAdvancedPDFViewer(true)}
                    className="px-3 py-1 text-xs bg-purple-100 text-purple-700 rounded hover:bg-purple-200"
                  >
                    Í≥†Í∏â PDF Î∑∞Ïñ¥ (Ï†ïÎ∞Ä ÌïòÏù¥ÎùºÏù¥Ìä∏)
                  </button>
                  {content && (
                    <button
                      onClick={() => setShowTextContent(!showTextContent)}
                      className="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
                    >
                      {showTextContent ? 'PDF Î≥¥Í∏∞ (Í≤ÄÏÉâ ÌïòÏù¥ÎùºÏù¥Ìä∏)' : 'ÌÖçÏä§Ìä∏ Î≥¥Í∏∞ (Ï†ïÌôïÌïú ÏúÑÏπò)'}
                    </button>
                  )}
                </div>
              )}
            </div>
            <div className="flex items-center space-x-2">
              <a
                href={`${API_BASE_URL}/projects/${file.id}/download`}
                className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm"
                download
              >
                ‚¨á Îã§Ïö¥Î°úÎìú
              </a>
            </div>
          </div>

          {/* PDF Content */}
          <div className="flex-1 overflow-hidden">
            {showTextContent && content ? (
              <div id="document-content" className="p-6 overflow-auto h-full">
                <div className="mb-4">
                  <div className="flex items-center justify-between">
                    <h3 className="text-lg font-medium mb-2">Ï∂îÏ∂úÎêú ÌÖçÏä§Ìä∏ ÎÇ¥Ïö© (ÌÇ§ÏõåÎìú ÌïòÏù¥ÎùºÏù¥ÌåÖ)</h3>
                    {targetPosition && (
                      <div className="text-sm bg-blue-50 text-blue-800 px-3 py-1 rounded">
                        Ïù¥Îèô Ï§ë: {targetPosition.page ? `ÌéòÏù¥ÏßÄ ${targetPosition.page}` : ''}
                        {targetPosition.line ? `, ÎùºÏù∏ ${targetPosition.line}` : ''}
                      </div>
                    )}
                  </div>
                  <p className="text-sm text-gray-600">PDFÏóêÏÑú Ï∂îÏ∂úÎêú ÌÖçÏä§Ìä∏ÏóêÏÑú ÌÇ§ÏõåÎìúÎ•º Í≤ÄÏÉâÌï† Ïàò ÏûàÏäµÎãàÎã§. ÏúÑÏπò Ïù¥Îèô Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©ÌïòÎ†§Î©¥ ÌÖçÏä§Ìä∏ Î≥¥Í∏∞Î•º Ïù¥Ïö©ÌïòÏÑ∏Ïöî.</p>
                </div>
                <pre 
                  className="whitespace-pre-wrap font-mono text-sm border p-4 bg-gray-50 rounded relative"
                  dangerouslySetInnerHTML={{ __html: highlightText(content) }}
                />
              </div>
            ) : (
              <div className="w-full h-full">
                {pdfUrl ? (
                  <div className="w-full h-full relative">
                    {(targetPosition || safeKeywords.length > 0) && (
                      <div className="absolute top-2 right-2 z-10 bg-yellow-100 text-yellow-800 px-3 py-1 rounded shadow text-sm max-w-xs">
                        {targetPosition && (
                          <>
                            üìç ÌéòÏù¥ÏßÄ {targetPosition.page}Î°ú Ïù¥ÎèôÎê® 
                            {targetPosition.line && (
                              <div className="text-xs mt-1">ÎùºÏù∏ {targetPosition.line} ÏúÑÏπòÎäî ÌÖçÏä§Ìä∏ Î≥¥Í∏∞ÏóêÏÑú ÌôïÏù∏ÌïòÏÑ∏Ïöî</div>
                            )}
                          </>
                        )}
                        {safeKeywords.length > 0 && (
                          <div className="text-xs mt-1">
                            üîç "{safeKeywords[0]}" Í≤ÄÏÉâ Ï§ë - Ctrl+FÎ°ú Îã§Ïùå Í≤∞Í≥º ÌÉêÏÉâ Í∞ÄÎä•
                          </div>
                        )}
                      </div>
                    )}
                    <iframe
                      src={pdfUrl}
                      title={`PDF Viewer - ${file.filename}`}
                      className="w-full h-full border-0"
                      style={{ minHeight: '600px' }}
                    />
                  </div>
                ) : (
                  <div className="flex items-center justify-center h-full">
                    <div className="text-center">
                      <p className="text-gray-600 mb-4">PDFÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë...</p>
                      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      );
    }

    return (
      <div id="document-content" className="p-6 overflow-auto h-full">
        <pre 
          className="whitespace-pre-wrap font-mono text-sm relative"
          style={{ lineHeight: '24px' }}
          dangerouslySetInnerHTML={{ __html: highlightText(content) }}
        />
      </div>
    );
  };

  // Í≥†Í∏â PDF Î∑∞Ïñ¥ ÏÇ¨Ïö© Ïãú
  if (useAdvancedPDFViewer && fileType === 'pdf') {
    return (
      <AdvancedPDFViewer
        file={file}
        keywords={safeKeywords}
        targetPosition={targetPosition}
        onClose={() => setUseAdvancedPDFViewer(false)}
      />
    );
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-30 z-50">
      <div 
        ref={modalRef}
        className={`bg-white rounded-lg shadow-2xl flex flex-col border border-gray-300 ${
          isMaximized 
            ? 'fixed inset-2' 
            : 'absolute'
        }`}
        style={isMaximized ? {} : {
          left: position.x,
          top: position.y,
          width: size.width,
          height: size.height,
          minWidth: '400px',
          minHeight: '300px'
        }}
        onMouseDown={handleMouseDown}
      >
        {/* Header */}
        <div 
          ref={headerRef}
          className={`flex items-center justify-between p-3 border-b bg-gray-50 rounded-t-lg ${
            !isMaximized ? 'cursor-move' : ''
          }`}
        >
          <div className="flex items-center space-x-3">
            <span className="text-gray-600">üìÑ</span>
            <h2 className="text-xl font-semibold">{file.filename}</h2>
          </div>
          <div className="flex items-center space-x-4">
            {safeKeywords.length > 0 && (
              <label className="flex items-center space-x-2 text-sm">
                <input
                  type="checkbox"
                  checked={highlightKeywords}
                  onChange={(e) => setHighlightKeywords(e.target.checked)}
                  className="rounded"
                />
                <span>ÌÇ§ÏõåÎìú ÌïòÏù¥ÎùºÏù¥Ìä∏</span>
              </label>
            )}
            <a
              href={`${API_BASE_URL}/projects/${file.id}/download`}
              className="flex items-center space-x-2 px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              <span>‚¨á</span>
              <span>Îã§Ïö¥Î°úÎìú</span>
            </a>
            <div className="flex items-center space-x-1">
              <button
                onClick={toggleMaximize}
                className="p-1.5 hover:bg-gray-200 rounded text-sm"
                title={isMaximized ? 'Î≥µÏõê' : 'ÏµúÎåÄÌôî'}
              >
                {isMaximized ? 'üóó' : 'üóñ'}
              </button>
              <button
                onClick={onClose}
                className="p-1.5 hover:bg-gray-200 rounded text-sm"
                title="Îã´Í∏∞"
              >
                ‚úï
              </button>
            </div>
          </div>
        </div>

        {/* Keyword pills */}
        {safeKeywords.length > 0 && highlightKeywords && (
          <div className="px-4 py-2 border-b bg-gray-50 flex flex-wrap gap-2">
            <span className="text-sm text-gray-600 mr-2">ÌÇ§ÏõåÎìú:</span>
            {safeKeywords.map((keyword, index) => (
              <span
                key={keyword}
                className="px-3 py-1 text-xs rounded-full"
                style={{ backgroundColor: `rgba(59, 130, 246, 0.3)` }}
              >
                {keyword}
              </span>
            ))}
          </div>
        )}

        {/* Content */}
        <div className="flex-1 overflow-hidden relative">
          {renderContent()}
        </div>
        
        {/* ÌÅ¨Í∏∞ Ï°∞Ï†à Ìï∏Îì§ */}
        {!isMaximized && (
          <div 
            className="absolute bottom-0 right-0 w-4 h-4 bg-gray-300 cursor-se-resize hover:bg-gray-400"
            style={{
              clipPath: 'polygon(100% 0%, 0% 100%, 100% 100%)'
            }}
            onMouseDown={handleResizeStart}
          />
        )}
      </div>
    </div>
  );
}