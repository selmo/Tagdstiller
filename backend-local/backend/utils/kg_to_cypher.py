"""
Knowledge Graph JSONì„ Cypher ì¿¼ë¦¬ë¡œ ë³€í™˜í•˜ëŠ” ìœ í‹¸ë¦¬í‹°

JSON í˜•ì‹ì˜ Knowledge Graphë¥¼ Neo4j/Memgraphìš© Cypher ì¿¼ë¦¬ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
"""

import json
from pathlib import Path
from typing import Dict, Any, List, Optional
import re


class KGToCypherConverter:
    """Knowledge Graph JSON â†’ Cypher ë³€í™˜ê¸°"""

    def __init__(self):
        self.node_id_to_var = {}  # ë…¸ë“œ IDë¥¼ Cypher ë³€ìˆ˜ëª…ìœ¼ë¡œ ë§¤í•‘
        self.created_nodes = set()  # ìƒì„±ëœ ë…¸ë“œ ì¶”ì 

    def convert_file(
        self,
        json_file_path: str,
        output_file_path: Optional[str] = None,
        clear_db: bool = False,
        create_indexes: bool = True
    ) -> str:
        """JSON íŒŒì¼ì„ ì½ì–´ Cypherë¡œ ë³€í™˜

        Args:
            json_file_path: ì…ë ¥ JSON íŒŒì¼ ê²½ë¡œ
            output_file_path: ì¶œë ¥ Cypher íŒŒì¼ ê²½ë¡œ (Noneì´ë©´ ìë™ ìƒì„±)
            clear_db: ë³€í™˜ ì „ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì—¬ë¶€
            create_indexes: ì¸ë±ìŠ¤ ìƒì„± ì¿¼ë¦¬ í¬í•¨ ì—¬ë¶€

        Returns:
            ìƒì„±ëœ Cypher ì¿¼ë¦¬ ë¬¸ìì—´
        """
        # JSON íŒŒì¼ ì½ê¸°
        with open(json_file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        # Cypher ìƒì„±
        cypher = self.convert(data, clear_db=clear_db, create_indexes=create_indexes)

        # ì¶œë ¥ íŒŒì¼ ê²½ë¡œ ê²°ì •
        if output_file_path is None:
            json_path = Path(json_file_path)
            output_file_path = json_path.parent / f"{json_path.stem}.cypher"

        # íŒŒì¼ ì €ì¥
        with open(output_file_path, 'w', encoding='utf-8') as f:
            f.write(cypher)

        print(f"âœ… Cypher íŒŒì¼ ìƒì„± ì™„ë£Œ: {output_file_path}")
        return cypher

    def convert(
        self,
        kg_data: Dict[str, Any],
        clear_db: bool = False,
        create_indexes: bool = True
    ) -> str:
        """Knowledge Graph JSONì„ Cypher ì¿¼ë¦¬ë¡œ ë³€í™˜

        Args:
            kg_data: Knowledge Graph JSON ë°ì´í„°
            clear_db: ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì¿¼ë¦¬ í¬í•¨ ì—¬ë¶€
            create_indexes: ì¸ë±ìŠ¤ ìƒì„± ì¿¼ë¦¬ í¬í•¨ ì—¬ë¶€

        Returns:
            Cypher ì¿¼ë¦¬ ë¬¸ìì—´
        """
        cypher_lines = []

        # í—¤ë”
        cypher_lines.append("// Knowledge Graph Import Script")
        cypher_lines.append("// Generated by KGToCypherConverter")
        cypher_lines.append("")

        # ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
        if clear_db:
            cypher_lines.append("// Clear database")
            cypher_lines.append("MATCH (n) DETACH DELETE n;")
            cypher_lines.append("")

        # ì¸ë±ìŠ¤ ìƒì„±
        if create_indexes:
            cypher_lines.extend(self._generate_indexes(kg_data))
            cypher_lines.append("")

        # ê·¸ë˜í”„ ë°ì´í„° ì¶”ì¶œ
        graph = kg_data.get("graph", kg_data)
        nodes = graph.get("nodes", graph.get("entities", []))
        edges = graph.get("edges", graph.get("relationships", []))

        # ë…¸ë“œ ìƒì„±
        cypher_lines.append("// ==================== Create Nodes ====================")
        cypher_lines.append("")
        node_queries = self._generate_node_queries(nodes)
        cypher_lines.extend(node_queries)
        cypher_lines.append("")

        # ê´€ê³„ ìƒì„±
        cypher_lines.append("// ==================== Create Relationships ====================")
        cypher_lines.append("")
        rel_queries = self._generate_relationship_queries(edges)
        cypher_lines.extend(rel_queries)
        cypher_lines.append("")

        # ë©”íƒ€ë°ì´í„° ì¶”ê°€ (ì„ íƒì )
        if "metadata" in kg_data:
            cypher_lines.append("// ==================== Add Metadata ====================")
            cypher_lines.append("")
            metadata_queries = self._generate_metadata_queries(kg_data["metadata"])
            cypher_lines.extend(metadata_queries)
            cypher_lines.append("")

        # í†µê³„
        cypher_lines.append("// ==================== Statistics ====================")
        cypher_lines.append(f"// Total Nodes: {len(nodes)}")
        cypher_lines.append(f"// Total Relationships: {len(edges)}")

        return "\n".join(cypher_lines)

    def _generate_indexes(self, kg_data: Dict[str, Any]) -> List[str]:
        """ì¸ë±ìŠ¤ ìƒì„± ì¿¼ë¦¬ ìƒì„±"""
        queries = ["// Create indexes for performance"]

        # ì—”í‹°í‹° íƒ€ì…ë³„ ì¸ë±ìŠ¤ ìƒì„±
        graph = kg_data.get("graph", kg_data)
        nodes = graph.get("nodes", graph.get("entities", []))

        entity_types = set()
        for node in nodes:
            node_type = node.get("type", "Unknown")
            entity_types.add(node_type)

        for entity_type in sorted(entity_types):
            # Neo4j/Memgraph ìŠ¤íƒ€ì¼ ì¸ë±ìŠ¤
            queries.append(f"CREATE INDEX IF NOT EXISTS FOR (n:{entity_type}) ON (n.id);")
            queries.append(f"CREATE INDEX IF NOT EXISTS FOR (n:{entity_type}) ON (n.name);")

        return queries

    def _generate_node_queries(self, nodes: List[Dict[str, Any]]) -> List[str]:
        """ë…¸ë“œ ìƒì„± ì¿¼ë¦¬ ìƒì„±"""
        queries = []

        for i, node in enumerate(nodes):
            node_id = node.get("id", f"node_{i}")
            node_type = node.get("type", "Unknown")
            properties = node.get("properties", {})

            # Cypher ë³€ìˆ˜ëª… ìƒì„± (ì•ŒíŒŒë²³+ìˆ«ìë§Œ)
            var_name = self._sanitize_var_name(node_id)
            self.node_id_to_var[node_id] = var_name

            # í”„ë¡œí¼í‹° ë¬¸ìì—´ ìƒì„±
            props = {"id": node_id}
            props.update(properties)

            props_str = self._format_properties(props)

            # CREATE ì¿¼ë¦¬ ìƒì„±
            query = f"CREATE ({var_name}:{node_type} {props_str});"
            queries.append(query)

            self.created_nodes.add(node_id)

        return queries

    def _generate_relationship_queries(self, edges: List[Dict[str, Any]]) -> List[str]:
        """ê´€ê³„ ìƒì„± ì¿¼ë¦¬ ìƒì„±"""
        queries = []

        for i, edge in enumerate(edges):
            edge_id = edge.get("id", f"edge_{i}")
            source_id = edge.get("source")
            target_id = edge.get("target")
            rel_type = edge.get("type", "RELATED_TO")
            properties = edge.get("properties", {})

            # ì†ŒìŠ¤/íƒ€ê²Ÿ ë…¸ë“œê°€ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
            if source_id not in self.created_nodes:
                queries.append(f"// Warning: Source node not found: {source_id}")
                continue
            if target_id not in self.created_nodes:
                queries.append(f"// Warning: Target node not found: {target_id}")
                continue

            # ë³€ìˆ˜ëª… ê°€ì ¸ì˜¤ê¸°
            source_var = self.node_id_to_var.get(source_id, f"src_{i}")
            target_var = self.node_id_to_var.get(target_id, f"tgt_{i}")

            # í”„ë¡œí¼í‹° ë¬¸ìì—´ ìƒì„±
            props = {"id": edge_id}
            props.update(properties)

            if props:
                props_str = " " + self._format_properties(props)
            else:
                props_str = ""

            # MATCH + CREATE ì¿¼ë¦¬ ìƒì„±
            query = (
                f"MATCH ({source_var} {{id: '{source_id}'}}), "
                f"({target_var} {{id: '{target_id}'}}) "
                f"CREATE ({source_var})-[:{rel_type}{props_str}]->({target_var});"
            )
            queries.append(query)

        return queries

    def _generate_metadata_queries(self, metadata: Dict[str, Any]) -> List[str]:
        """ë©”íƒ€ë°ì´í„° ë…¸ë“œ ìƒì„± ì¿¼ë¦¬"""
        queries = []

        # ë©”íƒ€ë°ì´í„°ë¥¼ ë³„ë„ ë…¸ë“œë¡œ ìƒì„±
        props_str = self._format_properties(metadata)
        queries.append(f"CREATE (meta:Metadata {props_str});")

        return queries

    def _sanitize_var_name(self, node_id: str) -> str:
        """ë…¸ë“œ IDë¥¼ Cypher ë³€ìˆ˜ëª…ìœ¼ë¡œ ë³€í™˜"""
        # ì•ŒíŒŒë²³, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´ë§Œ í—ˆìš©
        sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', node_id)
        # ìˆ«ìë¡œ ì‹œì‘í•˜ë©´ ì•ì— 'n' ì¶”ê°€
        if sanitized and sanitized[0].isdigit():
            sanitized = 'n' + sanitized
        return sanitized or 'node'

    def _format_properties(self, properties: Dict[str, Any]) -> str:
        """í”„ë¡œí¼í‹°ë¥¼ Cypher í˜•ì‹ìœ¼ë¡œ í¬ë§·"""
        if not properties:
            return "{}"

        prop_parts = []
        for key, value in properties.items():
            # í‚¤ sanitize
            safe_key = re.sub(r'[^a-zA-Z0-9_]', '_', key)

            # ê°’ í¬ë§·
            if isinstance(value, str):
                # ë¬¸ìì—´ ì´ìŠ¤ì¼€ì´í”„
                escaped = value.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
                prop_parts.append(f"{safe_key}: '{escaped}'")
            elif isinstance(value, bool):
                prop_parts.append(f"{safe_key}: {str(value).lower()}")
            elif isinstance(value, (int, float)):
                prop_parts.append(f"{safe_key}: {value}")
            elif value is None:
                prop_parts.append(f"{safe_key}: null")
            elif isinstance(value, (list, dict)):
                # ë³µì¡í•œ íƒ€ì…ì€ JSON ë¬¸ìì—´ë¡œ ë³€í™˜
                json_str = json.dumps(value, ensure_ascii=False)
                escaped = json_str.replace("\\", "\\\\").replace("'", "\\'")
                prop_parts.append(f"{safe_key}: '{escaped}'")
            else:
                # ê¸°íƒ€ íƒ€ì…ì€ ë¬¸ìì—´ë¡œ ë³€í™˜
                prop_parts.append(f"{safe_key}: '{str(value)}'")

        return "{" + ", ".join(prop_parts) + "}"


def convert_kg_json_to_cypher(
    json_file: str,
    output_file: Optional[str] = None,
    clear_db: bool = False,
    create_indexes: bool = True
) -> str:
    """Knowledge Graph JSON íŒŒì¼ì„ Cypherë¡œ ë³€í™˜í•˜ëŠ” í¸ì˜ í•¨ìˆ˜

    Args:
        json_file: ì…ë ¥ JSON íŒŒì¼ ê²½ë¡œ
        output_file: ì¶œë ¥ Cypher íŒŒì¼ ê²½ë¡œ (Noneì´ë©´ ìë™)
        clear_db: ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” í¬í•¨ ì—¬ë¶€
        create_indexes: ì¸ë±ìŠ¤ ìƒì„± í¬í•¨ ì—¬ë¶€

    Returns:
        ìƒì„±ëœ Cypher ì¿¼ë¦¬ ë¬¸ìì—´
    """
    converter = KGToCypherConverter()
    return converter.convert_file(
        json_file,
        output_file,
        clear_db=clear_db,
        create_indexes=create_indexes
    )


if __name__ == "__main__":
    import sys

    # --help ì²˜ë¦¬
    if len(sys.argv) < 2 or '--help' in sys.argv or '-h' in sys.argv:
        print("Usage: python kg_to_cypher.py <json_file> [output_file] [--clear-db] [--no-indexes]")
        print()
        print("Arguments:")
        print("  json_file       ì…ë ¥ Knowledge Graph JSON íŒŒì¼")
        print("  output_file     ì¶œë ¥ Cypher íŒŒì¼ (ì„ íƒì‚¬í•­, ê¸°ë³¸ê°’: <json_file>.cypher)")
        print()
        print("Options:")
        print("  --clear-db      ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì¿¼ë¦¬ í¬í•¨ (MATCH (n) DETACH DELETE n)")
        print("  --no-indexes    ì¸ë±ìŠ¤ ìƒì„± ì¿¼ë¦¬ ì œì™¸")
        print("  -h, --help      ì´ ë„ì›€ë§ í‘œì‹œ")
        print()
        print("Examples:")
        print("  python kg_to_cypher.py knowledge_graph.json")
        print("  python kg_to_cypher.py knowledge_graph.json output.cypher")
        print("  python kg_to_cypher.py knowledge_graph.json --clear-db")
        print("  python kg_to_cypher.py knowledge_graph.json output.cypher --clear-db --no-indexes")
        sys.exit(0 if '--help' in sys.argv or '-h' in sys.argv else 1)

    json_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 and not sys.argv[2].startswith('--') else None
    clear_db = '--clear-db' in sys.argv
    create_indexes = '--no-indexes' not in sys.argv

    print(f"ğŸ“„ JSON íŒŒì¼: {json_file}")
    print(f"ğŸ“ ì¶œë ¥ íŒŒì¼: {output_file or 'ìë™ ìƒì„±'}")
    print(f"ğŸ—‘ï¸  DB ì´ˆê¸°í™”: {clear_db}")
    print(f"ğŸ“Š ì¸ë±ìŠ¤ ìƒì„±: {create_indexes}")
    print()

    try:
        cypher = convert_kg_json_to_cypher(
            json_file,
            output_file,
            clear_db=clear_db,
            create_indexes=create_indexes
        )

        # í†µê³„ ì¶œë ¥
        node_count = cypher.count("CREATE (")
        rel_count = cypher.count("CREATE (") - cypher.count("CREATE (meta:")

        print(f"ğŸ“Š ìƒì„±ëœ ì¿¼ë¦¬:")
        print(f"   - ë…¸ë“œ: {node_count}ê°œ")
        print(f"   - ê´€ê³„: {rel_count}ê°œ")
        print(f"   - ì´ ë¼ì¸: {len(cypher.splitlines())}ì¤„")

    except Exception as e:
        print(f"âŒ ì˜¤ë¥˜: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
